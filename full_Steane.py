import stim
print(stim.__version__)
import numpy as np
import time
import random, re, pickle
from collections import  Counter
from functools import reduce
from PyDecoder_polar import PyDecoder_polar_SCL

N = 2 ** 7
p_CNOT = 0.001
p_single = p_CNOT/10

decoder_Z = PyDecoder_polar_SCL(4)
# decoder_X = PyDecoder_polar_SCL(3)
# helper function: take a PauliString and return its Z-component
def z_component(s):
    x, z = s.to_numpy()
    return stim.PauliString.from_numpy(xs=np.zeros_like(x, dtype=np.bool_), zs=z)
def x_component(s):
    x, z = s.to_numpy()
    return stim.PauliString.from_numpy(xs=x, zs=np.zeros_like(z, dtype=np.bool_))

def sample_ancilla_error(num_shots, d, state, index):
    with open(f"logs_prep_d{d}_{state}/propagation_dict.pkl", 'rb') as f:
        prop_dict = pickle.load(f)

    with open(f"logs_prep_d{d}_{state}/{index}_single_fault.pkl", 'rb') as f:
        fault_dict = pickle.load(f)

    with open(f"logs_prep_d{d}_{state}/{index}.log", 'r') as f:
        lines = f.readlines(0)
        target_line = lines[-2].strip()
        match = re.search(r'Counter\((\{.*\})\)', target_line)
        if match:
            # print("group 0", match.group(0))
            counter_dict_str = match.group(1) # extract the dictionary part
            counter_dict = eval(counter_dict_str) # evaluate dict string into dict
            # print(counter_dict)
            counter_obj = Counter(counter_dict)
            num_no_fault = counter_obj[0]

    fault_dict["none"] = num_no_fault

    with open(f"logs_prep_d{d}_{state}/{index}_faults.log", 'r') as f:
        lines = f.readlines(0)
        # print(f"number of lines in {index}_faults.log: {len(lines)}")
        for line in lines:
            line = line.strip()[1:-1]
            string_values = line.split()
            int_values = tuple(sorted([int(value) for value in string_values]))
            if int_values in fault_dict.keys():  
                fault_dict[int_values] += 1
            else:
                fault_dict[int_values] = 0

    # print(len(fault_dict))

    start = time.time()
    ancilla = random.sample(list(fault_dict.keys()), 10000, counts=list(fault_dict.values()))
    # print(ancilla)
    end = time.time()
    print(f"sampling {num_shots} samples elapsed time {end-start} seconds")

    ancilla_errors = []
    for a in ancilla:
        if a == 'none': # no faults 
            ancilla_errors.append(stim.PauliString(N))
        elif isinstance(a, tuple): # multiple fault locations
            ancilla_errors.append(reduce(stim.PauliString.__mul__, [prop_dict[i] for i in a], stim.PauliString(N)))
        else: # a single fault
            ancilla_errors.append(prop_dict[a])

    return ancilla_errors

# need input PauliString: incoming noise
# need anilla residual PauliString, temporarily generated by using noisy transversal CNOT between first and last N//2
# later need to load from my samples, and preprocess using decoder for degeneracy
# generate error on CNOTs coupling data and anilla (DEPOLARIZE2)
# generate measurement error (flip error)
# need to call decoder
# generate correction operator error (DEPOLARIZE1)
bs = 1024
# phase error Steane EC block
def phase_flip_EC_block(input_errors=None, ancilla_errors=None, use_decoder=False):
    if input_errors is None:
        input_errors = [stim.PauliString(N) for _ in range(bs)]
    if ancilla_errors is None:
        ancilla_prep_circuit = stim.Circuit()
        for i in range(N-1): # last round correction residual depolarizing noise
            ancilla_prep_circuit.append("DEPOLARIZE1", i, p_single)
        for i in range(N//2):
            ancilla_prep_circuit.append("CNOT", [i, i+N//2])
            ancilla_prep_circuit.append("DEPOLARIZE2", [i, i+N//2], p_CNOT)
        ancilla_prep_sim = stim.FlipSimulator(batch_size=bs, num_qubits=N, disable_stabilizer_randomization=True)
        ancilla_prep_sim.do(ancilla_prep_circuit)
        ancilla_errors = ancilla_prep_sim.peek_pauli_flips()

    # broadcast incoming noise to qubit 0 ~ N-1
    # broadcast ancilla noise to qubit N ~ 2N-1
    before_coupling_errors = [e1+e2 for (e1,e2) in zip(input_errors, ancilla_errors)] # list of length 2N PauliString
    
    
    coupling_circuit = stim.Circuit()
    for i in range(N-1):
        coupling_circuit.append("CNOT", [i+N, i])
        coupling_circuit.append("DEPOLARIZE2", [i+N, i], p_CNOT)

    for i in range(N-1): # measurement noise
        coupling_circuit.append("Z_ERROR", N+i, p_single)
    coupling_sim = stim.FlipSimulator(batch_size=bs, num_qubits=2*N, disable_stabilizer_randomization=True)
    
    X_component, Z_component = np.array([e.to_numpy() for e in before_coupling_errors]).transpose(1,2,0) # each shape (2*N, bs)
    print(f"X component shape {X_component.shape}, Z component shape {Z_component.shape}")
    coupling_sim.broadcast_pauli_errors(pauli='X', mask=X_component)
    coupling_sim.broadcast_pauli_errors(pauli='Z', mask=Z_component)

    coupling_sim.do(coupling_circuit)
    coupling_errors = coupling_sim.peek_pauli_flips()

    if use_decoder:
        # look at Z component on qubit N ~ 2N-1 and try to correct
        noise = list(map(lambda s: z_component(s[N:]), coupling_errors))
        # print("phase-flip noise", noise)
        # TODO: call decoder
        num_errors = 0
        for n in noise:
            num_flip = decoder_Z.decode(list(np.nonzero(n)[0]))
            class_bit = decoder_Z.last_info_bit
            if class_bit != 0:
                num_errors += 1
        residual_errors = list(map(lambda s: s[:N] * z_component(s[N:]), coupling_errors))
        return residual_errors, num_errors
    else: # assume perfect correction first
        residual_errors = list(map(lambda s: s[:N] * z_component(s[N:]), coupling_errors))
        return residual_errors

def bit_flip_EC_block(input_errors=None, ancilla_errors=None, use_decoder=False):
    if input_errors is None:
        input_errors = [stim.PauliString(N) for _ in range(bs)]
    if ancilla_errors is None:
        ancilla_prep_circuit = stim.Circuit()
        for i in range(N-1): # last round correction residual depolarizing noise
            ancilla_prep_circuit.append("DEPOLARIZE1", i, p_single)
        for i in range(N//2):
            ancilla_prep_circuit.append("CNOT", [i, i+N//2])
            ancilla_prep_circuit.append("DEPOLARIZE2", [i, i+N//2], p_CNOT)
        ancilla_prep_sim = stim.FlipSimulator(batch_size=bs, num_qubits=N, disable_stabilizer_randomization=True)
        ancilla_prep_sim.do(ancilla_prep_circuit)
        ancilla_errors = ancilla_prep_sim.peek_pauli_flips()

    # broadcast incoming noise to qubit 0 ~ N-1
    # broadcast ancilla noise to qubit N ~ 2N-1
    before_coupling_errors = [e1+e2 for (e1,e2) in zip(input_errors, ancilla_errors)] # list of length 2N PauliString
    
    
    coupling_circuit = stim.Circuit()
    for i in range(N-1):
        coupling_circuit.append("CNOT", [i, i+N])
        coupling_circuit.append("DEPOLARIZE2", [i, i+N], p_CNOT)

    for i in range(N-1): # measurement noise
        coupling_circuit.append("X_ERROR", N+i, p_single)
    coupling_sim = stim.FlipSimulator(batch_size=bs, num_qubits=2*N, disable_stabilizer_randomization=True)
    
    X_component, Z_component = np.array([e.to_numpy() for e in before_coupling_errors]).transpose(1,2,0) # each shape (2*N, bs)
    coupling_sim.broadcast_pauli_errors(pauli='X', mask=X_component)
    coupling_sim.broadcast_pauli_errors(pauli='Z', mask=Z_component)

    coupling_sim.do(coupling_circuit)
    coupling_errors = coupling_sim.peek_pauli_flips()

    if use_decoder:
        # look at X component on qubit N ~ 2N-1 and try to correct
        noise = list(map(lambda s: x_component(s[N:]), coupling_errors))
        # print("bit-flip noise", noise)
        # TODO: call decoder
        residual_errors = list(map(lambda s: s[:N] * x_component(s[N:]), coupling_errors))
    else: # assume perfect correction first
        residual_errors = list(map(lambda s: s[:N] * x_component(s[N:]), coupling_errors))
        
    return residual_errors

total_num_errors = 0
num_batch = 200
num_shots = num_batch * bs
start = time.time()
a1_d15_zero = sample_ancilla_error(num_shots, 15, 'zero', 0)
a2_d7_plus = sample_ancilla_error(num_shots, 7, 'plus', 0)
a3_d15_zero = sample_ancilla_error(num_shots, 15, 'zero', 1)
for round in range(num_batch):
    s_start = round * bs
    s_end = s_start + bs
    residual_errors_b1 = phase_flip_EC_block(ancilla_errors=a1_d15_zero[s_start:s_end])
    residual_errors_b2 = bit_flip_EC_block(residual_errors_b1, a2_d7_plus[s_start:s_end])
    # print(residual_errors_b2)
    # TODO: logical gates
    residual_errors_b3, num_errors = phase_flip_EC_block(residual_errors_b2, a3_d15_zero[s_start:s_end], use_decoder=True)
    total_num_errors += num_errors
    print(f"#errors/#samples: {total_num_errors}/{s_end}")
    print(f"error rate: {total_num_errors/(s_end)}")
end = time.time()
print(f"Total elasped time {end-start} seconds.")